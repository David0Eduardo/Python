from flask import Flask, jsonify, request
import pyodbc
import jwt
import os
from dotenv import load_dotenv
from pathlib import Path

app = Flask(__name__)

# Configurações do banco de dados
server = 'IP,Porta'
instance = 'SQL'
username_db = 'sa'
password_db = 'senha'

# Database de login dos Usuarios
database_users = 'ACESSO_API'

# Carregar variáveis de ambiente
env_path = Path('.')/'key.env'
load_dotenv(dotenv_path=env_path)
SECRET_KEY = os.getenv('SECRET_KEY')

# Conexão com o banco de dados
def connect_to_database(server, instance, database, username, password):
    connection_string = f'DRIVER={{SQL Server}};SERVER={server}\\{instance};DATABASE={database};UID={username};PWD={password};'
    try:
        conn = pyodbc.connect(connection_string)
        return conn
    except pyodbc.Error as e:
        print("Erro ao conectar ao banco de dados:", e)
        return None


# Geração de token JWT
def generate_token(user_id, allowed_databases, database):
    """Gera o token JWT apenas com as permissões do usuário verificadas no banco."""
    try:
        # Se for admin, setamos 'admin' no token
        if database == 'admin':
            allowed_databases = ['admin']
        payload = {
            'user_id': int(user_id),
            'allowed_databases': allowed_databases
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
        return token
    except Exception as e:
        print("Erro ao gerar token:", e)
        return None

# Função para verificar o token
def verify_token(request, database_requested):
    """Função para verificar se o token é válido e se a base solicitada está entre as permitidas."""
    auth_header = request.headers.get('Authorization')
    if auth_header and auth_header.startswith('Bearer '):
        token = auth_header.split(" ")[1]
        try:
            # Decodificar token
            payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
            user_id = payload.get('user_id')
            allowed_databases = payload.get('allowed_databases')

            # Lógica de acesso total para admin
            if 'admin' in allowed_databases:
                return user_id, None, "admin"  # Permissão total para qualquer base
            
            # Verifica se a base está entre as permitidas
            if database_requested in allowed_databases:
                return user_id, None, "user"
            else:
                return None, "Acesso não autorizado à base de dados"
        except jwt.ExpiredSignatureError:
            return None, "Token expirado"
        except jwt.InvalidTokenError:
            return None, "Token inválido"
    return None, "Token ausente ou malformado"

# Função para verificar se usuário está ativo e obter suas permissões no banco de dados
def is_user_active_and_check_database(username):
    try:
        conn = connect_to_database(server, instance, database_users, username_db, password_db)
        if conn is None:
            return None

        cursor = conn.cursor()
        # Escapar com [] para evitar conflitos com palavras reservadas
        query = "SELECT Status, Database FROM [dbo].[tb_acesso_usuario] WHERE [User] = ?"
        cursor.execute(query, (username,))
        user_row = cursor.fetchone()

        if user_row:
            status, allowed_databases = user_row
            if status.strip().upper() == 'UP':
                allowed_databases_list = allowed_databases.split(';')
                cursor.close()
                conn.close()
                return allowed_databases_list
        cursor.close()
        conn.close()
        return None
    except Exception as e:
        print("Erro ao verificar usuário ativo ou permissões:", str(e))
        return None

# Endpoint de login
@app.route('/login', methods=['POST'])
def login():
    data = request.json
    if not data:
        return jsonify({"error": "Tipo de mídia não suportado"}), 415

    username = data.get('username')
    password = data.get('password')

    try:
        conn = connect_to_database(server, instance, database_users, username_db, password_db)
        if conn is None:
            return jsonify({"error": "Falha na conexão com o banco de dados"}), 500

        cursor = conn.cursor()
        query = "SELECT [Password], [User_ID], [Database] FROM [dbo].[tb_acesso_usuario] WHERE [User] = ?"
        cursor.execute(query, (username,))
        user_row = cursor.fetchone()

        if user_row:
            db_password, user_id, allowed_databases = user_row
            if db_password == password:
                allowed_databases_list = allowed_databases.split(';')
                
                # Checar se é permissão admin
                if 'admin' in allowed_databases_list:
                    token = generate_token(user_id, allowed_databases_list, 'admin')
                else:
                    token = generate_token(user_id, allowed_databases_list, allowed_databases)

                if token:
                    return jsonify({'token': token}), 200
                else:
                    return jsonify({'error': 'Erro ao gerar token'}), 500
            else:
                return jsonify({'error': 'Senha inválida'}), 401
        else:
            return jsonify({'error': 'Usuário não encontrado'}), 401
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

# Endpoint para consulta de dados
@app.route('/<database>/<table_name>', methods=['GET'])
def get_dados(database, table_name):
    user_id, error = verify_token(request, database)

    if error:
        return jsonify({"error": error}), 401

    try:
        conn = connect_to_database(server, instance, database, username_db, password_db)
        if conn is None:
            return jsonify({"error": "Falha na conexão com o banco de dados"}), 500

        cursor = conn.cursor()
        # Verifica se a tabela existe
        cursor.execute("SELECT * FROM [information_schema].[tables] WHERE table_name = ?", (table_name,))
        if not cursor.fetchone():
            return jsonify({"error": "Tabela não encontrada"}), 404

        # Executa a consulta na tabela
        cursor.execute("SELECT * FROM [dbo].[{}]".format(table_name))
        colunas = [desc[0] for desc in cursor.description]
        rows = cursor.fetchall()
        dados = [{colunas[i]: row[i] for i in range(len(row))} for row in rows]

        return jsonify(dados)
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

#Endpoint para inserção de dados
@app.route('/<database>/<table_name>', methods=['POST'])
def insert_dados(database, table_name):
    user_id, error, role = verify_token(request, database)

    if error:
        return jsonify({"error": error}), 401

    # Somente admin pode usar DELETE/DROP
    if role != "admin":
        return jsonify({"error": "Acesso negado. Apenas administradores podem executar esta operação."}), 403

    data = request.get_json()
    if not data:
        return jsonify({"error": "JSON vazio ou inválido"}), 400

    # Garante que sempre seja uma lista
    if isinstance(data, dict):
        data = [data]  # transforma registro único em lista

    try:
        conn = connect_to_database(server, instance, database, username_db, password_db)
        if conn is None:
            return jsonify({"error": "Falha na conexão com o banco de dados"}), 500

        cursor = conn.cursor()

        # Verifica se a tabela existe
        cursor.execute(
            "SELECT * FROM [information_schema].[tables] WHERE table_name = ?", (table_name,)
        )
        if not cursor.fetchone():
            return jsonify({"error": "Tabela não encontrada"}), 404

        # Insere cada registro da lista
        for item in data:
            colunas = ", ".join([f"[{k}]" for k in item.keys()])
            placeholders = ", ".join(["?"] * len(item))
            valores = tuple(item.values())

            query = f"INSERT INTO [dbo].[{table_name}] ({colunas}) VALUES ({placeholders})"
            cursor.execute(query, valores)

        conn.commit()

        return jsonify({
            "message": "Registros inseridos com sucesso",
            "tabela": table_name,
            "quantidade": len(data),
            "dados": data
        }), 201

    except Exception as e:
        conn.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

# Endpoint para deletar ou dropar tabela
@app.route('/<database>/<table_name>', methods=['DELETE'])
def drop_or_delete(database, table_name):
    user_id, error, role = verify_token(request, database)

    if error:
        return jsonify({"error": error}), 401

    # Somente admin pode usar DELETE/DROP
    if role != "admin":
        return jsonify({"error": "Acesso negado. Apenas administradores podem executar esta operação."}), 403

    data = request.get_json()
    if not data or "command" not in data:
        return jsonify({"error": "JSON deve conter o campo 'command'"}), 400

    command = data["command"].upper()  # Normaliza
    criteria = data.get("criteria")    # Opcional no DELETE

    try:
        conn = connect_to_database(server, instance, database, username_db, password_db)
        if conn is None:
            return jsonify({"error": "Falha na conexão com o banco de dados"}), 500

        cursor = conn.cursor()

        # Verifica se a tabela existe
        cursor.execute(
            "SELECT * FROM [information_schema].[tables] WHERE table_name = ?", (table_name,)
        )
        if not cursor.fetchone():
            return jsonify({"error": "Tabela não encontrada"}), 404

        # Executa comando
        if command == "DROP":
            sql = f"DROP TABLE [dbo].[{table_name}]"
            cursor.execute(sql)

        elif command == "DELETE":
            if criteria:
                conditions = [f"[{col}] = ?" for col in criteria.keys()]
                where_clause = " AND ".join(conditions)
                sql = f"DELETE FROM [dbo].[{table_name}] WHERE {where_clause}"
                values = tuple(criteria.values())
                cursor.execute(sql, values)
            else:
                sql = f"DELETE FROM [dbo].[{table_name}]"
                cursor.execute(sql)
        else:
            return jsonify({"error": "Comando inválido. Use 'DROP' ou 'DELETE'"}), 400

        conn.commit()

        return jsonify({
            "message": f"Comando executado com sucesso: {sql}",
            "database": database,
            "tabela": table_name,
            "criteria": criteria if criteria else "Todos os registros"
        }), 200

    except Exception as e:
        conn.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

# Inicia o servidor
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
